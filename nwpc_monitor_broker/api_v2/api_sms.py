# coding=utf-8

import datetime
import gzip

import requests
from flask import request, jsonify, json

from nwpc_monitor_broker import app
from nwpc_monitor_broker.api_v2 import api_v2_app
from nwpc_monitor_broker.api_v2 import cache
from nwpc_monitor_broker.api_v2 import data_store
from nwpc_monitor_broker.api_v2 import ding_talk, weixin
from nwpc_work_flow_model.sms import Bunch, ErrorStatusTaskVisitor, pre_order_travel

REQUEST_POST_TIME_OUT = 20


def is_new_abort_task_found(owner: str, repo: str, previous_server_status: str, error_task_dict_list:list):
    """
    是否发现新的出错任务

    问题：
        如果大量作业出错，可能会导致发送大量警报
    :param owner:
    :param repo:
    :param previous_server_status:
    :param error_task_dict_list:
    :return:
    """

    new_error_task_found = True

    if previous_server_status == 'abo':
        new_error_task_found = False
        cached_error_task_value = cache.get_error_task_list_from_cache(owner, repo)
        cached_error_task_name_list = [a_task_item['path'] for a_task_item in
                                       cached_error_task_value['error_task_list'] ]
        for a_task in error_task_dict_list:
            if a_task['path'] not in cached_error_task_name_list:
                new_error_task_found = True
                break

    return new_error_task_found


def is_new_abort_root_found(owner: str, repo: str, previous_server_status: str, current_server_status: str='abo'):
    """
    是否刚发现根节点为出错状态

    问题：
        当有其它 suite 已经出错时，如果有新的 suite 出错，不会发送警报
    :param owner:
    :param repo:
    :param previous_server_status:
    :param current_server_status:
    """

    if previous_server_status != 'abo' and current_server_status == 'abo':
        return True
    else:
        return False


def sms_status_message_handler(message_data: dict) -> None:
    """
    message_data:
    {
        "name": "sms_status_message_data",
        "type": "record",
        "fields": [
            {"name": "owner", "type": "string"},
            {"name": "repo", "type": "string"},
            {"name": "sms_name", "type": "string"},
            {"name": "time", "type": "string"},
            {
                "name": "status",
                "doc": "bunch status",
                "type": { "type": "node" }
            }
        ]
    }
    """
    owner = message_data['owner']
    repo = message_data['repo']
    sms_name = message_data['sms_name']   # sms_name 应该与 repo 一致
    # sms_user = message_data['sms_user']
    message_time = message_data['time']

    bunch_dict = message_data['status']
    message_datetime = datetime.datetime.strptime(message_time, "%Y-%m-%dT%H:%M:%S.%f")

    warn_user_list = data_store.get_ding_talk_warn_user_list(owner, repo)

    sms_server_key = "{owner}/{repo}/status".format(owner=owner, repo=repo)
    print(sms_server_key)

    takler_object_system_store_flag = False
    takler_object_system_dict = None

    if len(bunch_dict) > 0:
        print('building bunch from message...')

        bunch = Bunch.create_from_dict(bunch_dict)

        # NOTE: Because Bunch.create_from_dict will use Bunch.name as path prefix, We need to set it to empty string.
        # So that its path begins with '/' as the same as path in bunch_dict generated by nwpc-log-collector.
        bunch.name = ''

        print('building bunch from message...Done')

        # find error tasks every suite
        suite_error_map = dict()
        error_task_dict_list = []
        for a_suite in bunch.children:
            error_visitor = ErrorStatusTaskVisitor()
            pre_order_travel(a_suite, error_visitor)
            suite_error_map[a_suite.name] = {
                'name': a_suite.name,
                'status': a_suite.status,
                'error_task_list': error_visitor.error_task_list
            }
            for a_task in error_visitor.error_task_list:
                error_task_dict_list.append(a_task.to_dict())

        server_status = bunch.status

        if server_status == 'abo':
            cached_sms_server_status = cache.get_sms_server_status_from_cache(owner, repo, sms_name)
            if cached_sms_server_status is not None:

                print('building bunch from cache message...')
                cached_bunch = Bunch.create_from_dict(cached_sms_server_status['status'])
                print('building bunch from cache message...Done')

                previous_server_status = cached_bunch.status

                # if True:
                if is_new_abort_task_found(owner, repo, previous_server_status, error_task_dict_list):
                    takler_object_system_dict = data_store.save_sms_server_status_to_nwpc_takler_object_system(
                        owner, repo, sms_name,
                        message_data, error_task_dict_list
                    )

                    takler_object_system_store_flag = True

                    aborted_tasks_blob_id = None
                    for a_blob in takler_object_system_dict['blobs']:
                        if a_blob['data']['type'] == 'aborted_tasks':
                            aborted_tasks_blob_id = a_blob['id']

                    warning_data = {
                        'owner': owner,
                        'repo': repo,
                        'sms_server_name': sms_name,  # bunch.name
                        'message_datetime': message_datetime,
                        'suite_error_map': suite_error_map,
                        'aborted_tasks_blob_id': aborted_tasks_blob_id
                    }

                    # ding_talk_app = ding_talk.DingTalkApp(
                    #     ding_talk_config=app.config['BROKER_CONFIG']['ding_talk_app'],
                    #     cloud_config=app.config['BROKER_CONFIG']['cloud']
                    # )
                    #
                    # ding_talk_app.send_warning_message(warning_data)

                    weixin_app = weixin.WeixinApp(
                        weixin_config=app.config['BROKER_CONFIG']['weixin_app'],
                        cloud_config=app.config['BROKER_CONFIG']['cloud']
                    )
                    weixin_app.send_warning_message(warning_data)

        # 保存 error_task_list 到缓存
        error_task_value = {
            'timestamp': datetime.datetime.now(),
            'error_task_list': error_task_dict_list
        }
        cache.save_error_task_list_to_cache(owner, repo, error_task_value)

        cache.save_sms_server_status_to_cache(owner, repo, sms_name, message_data)

        # 发送给外网服务器
        website_url = app.config['BROKER_CONFIG']['cloud']['put']['url'].format(
            owner=owner,
            repo=repo
        )
        if takler_object_system_store_flag:
            post_message = {
                'app': 'nwpc_monitor_broker',
                'event': 'post_sms_status',
                'timestamp': datetime.datetime.now(),
                'data': {
                    'type': 'takler_object',
                    'blobs': takler_object_system_dict['blobs'],
                    'trees': takler_object_system_dict['trees'],
                    'commits': takler_object_system_dict['commits']
                }
            }

            website_post_data = {
                'message': json.dumps(post_message)
            }
        else:
            message_data['type'] = 'status'
            post_message = {
                'app': 'nwpc_monitor_broker',
                'event': 'post_sms_status',
                'timestamp': datetime.datetime.now(),
                'data': message_data
            }
            website_post_data = {
                'message': json.dumps(post_message)
            }

        print('gzip the data...')
        gzipped_post_data = gzip.compress(bytes(json.dumps(website_post_data), 'utf-8'))
        print('gzip the data...done')

        response = requests.post(
            website_url,
            data=gzipped_post_data,
            headers={
                'content-encoding': 'gzip'
            },
            timeout=REQUEST_POST_TIME_OUT
        )
        print(response)
        return


@api_v2_app.route('/hpc/sms/status', methods=['POST'])
def receive_sms_status_message():
    """
    接收外部发送来的 SMS 服务器的状态，将其保存到本地缓存，并发送到外网服务器
    :return:
    """
    start_time = datetime.datetime.now()

    content_encoding = request.headers.get('content-encoding', '').lower()
    if content_encoding == 'gzip':
        gzipped_data = request.data
        data_string = gzip.decompress(gzipped_data)
        body = json.loads(data_string.decode('utf-8'))
    else:
        body = request.form

    message = json.loads(body['message'])

    if 'error' in message:
        result = {
            'status': 'ok'
        }
        return jsonify(result)

    message_data = message['data']
    sms_status_message_handler(message_data)

    result = {
        'status': 'ok'
    }
    end_time = datetime.datetime.now()
    print(end_time - start_time)

    return jsonify(result)


@api_v2_app.route('/hpc/sms/<owner>/<repo>/node-task', methods=['POST'])
def receive_sms_node_task_message(owner, repo):
    """
    
    :param owner: 
    :param repo: 
    :return: 
    
    post data:
    message:
    {
        'app': 'nwpc_monitor_task_scheduler',
        'type': 'sms_node_task',
        'timestamp': datetime.datetime.now().isoformat(),
        'data': {
            'owner': args['owner'],
            'repo': args['repo'],
            'request': {
                'task': args['task'],
            },
            'response': {
                'nodes': [
                    {
                        'node_path': node path,
                        'type': check type
                        'variables': [
                            {
                                'name': var_name,
                                'type': var_type,
                                'expected_value': expected_var_value,
                                'value': var.value,
                                'is_condition_fit': is_condition_fit       
                            },
                            ...
                        ]
                    },
                    ...
                ]
            }
        }
    }
    """
    content_encoding = request.headers.get('content-encoding', '').lower()
    if content_encoding == 'gzip':
        gzipped_data = request.data
        data_string = gzip.decompress(gzipped_data)
        body = json.loads(data_string.decode('utf-8'))
    else:
        body = request.form

    message = json.loads(body['message'])
    message_data = message['data']
    task_name = message_data['request']['task']['name']

    unfit_node_list = []

    node_result = message_data['response']['nodes']
    for a_node_record in node_result:
        node_path = a_node_record['node_path']
        check_type = a_node_record['type']

        if check_type == "variable":
            check_result = a_node_record['check_result']
            has_unfit_var_flag = False
            unfit_variable_list = []
            for a_variable in check_result:
                if a_variable['is_condition_fit'] is True:
                    continue
                has_unfit_var_flag = True
                unfit_variable_list.append(a_variable)
            if has_unfit_var_flag:
                unfit_node_list.append({
                    'node_path': node_path,
                    'type': check_type,
                    'unfit_variables': unfit_variable_list
                })

        elif check_type == "status":
            if 'error' in a_node_record:
                print(a_node_record['error'])
                continue

            check_result = a_node_record['check_result']
            if check_result['is_condition_fit'] is True:
                continue
            unfit_node_list.append({
                'node_path': node_path,
                'type': check_type,
                'check_result': check_result
            })

    print(unfit_node_list)
    if len(unfit_node_list) > 0:
        result = {
            'app': 'nwpc_monitor_broker',
            'type': 'sms_node_task',
            'timestamp': datetime.datetime.now().isoformat(),
            'data': {
                'owner': owner,
                'repo': repo,
                'task_name': task_name,
                'unfit_nodes': unfit_node_list
            }
        }

        weixin_app = weixin.WeixinApp(
            weixin_config=app.config['BROKER_CONFIG']['weixin_app'],
            cloud_config=app.config['BROKER_CONFIG']['cloud']
        )
        weixin_app.send_sms_node_task_warn(result)
    # else:
    #     # debug message.
    #     result = {
    #         'app': 'nwpc_monitor_broker',
    #         'type': 'sms_node_task',
    #         'timestamp': datetime.datetime.now().isoformat(),
    #         'data': {
    #             'owner': owner,
    #             'repo': repo,
    #             'task_name': task_name,
    #         }
    #     }
    #
    #     weixin_app = weixin.WeixinApp(
    #         weixin_config=app.config['BROKER_CONFIG']['weixin_app'],
    #         cloud_config=app.config['BROKER_CONFIG']['cloud']
    #     )
    #     weixin_app.send_sms_node_task_message(result)

    response_result = {
        'status': 'ok'
    }
    return jsonify(response_result)
