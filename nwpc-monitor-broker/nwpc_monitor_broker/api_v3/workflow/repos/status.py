# coding=utf-8

import datetime
import gzip

import requests
from flask import request, jsonify, json, current_app

from nwpc_monitor_broker.api_v3 import api_v3_app
from nwpc_monitor_broker.common import weixin, data_store
from nwpc_work_flow_model.sms import Bunch, ErrorStatusTaskVisitor, pre_order_travel

from nwpc_monitor_broker.common.workflow.status_strategry import is_new_abort_task_found, is_new_abort_root_found

REQUEST_POST_TIME_OUT = 20


def sms_status_message_handler(message_data: dict) -> None:
    """
    message_data:
    {
        "name": "sms_status_message_data",
        "type": "record",
        "fields": [
            {"name": "owner", "type": "string"},
            {"name": "repo", "type": "string"},
            {"name": "sms_name", "type": "string"},
            {"name": "time", "type": "string"},
            {
                "name": "status",
                "doc": "bunch status",
                "type": { "type": "node" }
            }
        ]
    }
    """
    owner = message_data['owner']
    repo = message_data['repo']
    sms_name = message_data['sms_name']   # sms_name 应该与 repo 一致
    # sms_user = message_data['sms_user']
    message_time = message_data['time']

    bunch_dict = message_data['status']
    message_datetime = datetime.datetime.strptime(message_time, "%Y-%m-%dT%H:%M:%S.%f")

    warn_user_list = data_store.get_ding_talk_warn_user_list(owner, repo)

    sms_server_key = "{owner}/{repo}/status".format(owner=owner, repo=repo)
    print(sms_server_key)

    takler_object_system_store_flag = False
    takler_object_system_dict = None

    if len(bunch_dict) > 0:
        print('building bunch from message...')

        bunch = Bunch.create_from_dict(bunch_dict)

        # NOTE: Because Bunch.create_from_dict will use Bunch.name as path prefix, We need to set it to empty string.
        # So that its path begins with '/' as the same as path in bunch_dict generated by nwpc-log-collector.
        bunch.name = ''

        print('building bunch from message...Done')

        # find error tasks every suite
        suite_error_map = dict()
        error_task_dict_list = []
        for a_suite in bunch.children:
            error_visitor = ErrorStatusTaskVisitor()
            pre_order_travel(a_suite, error_visitor)
            suite_error_map[a_suite.name] = {
                'name': a_suite.name,
                'status': a_suite.status,
                'error_task_list': error_visitor.error_task_list
            }
            for a_task in error_visitor.error_task_list:
                error_task_dict_list.append(a_task.to_dict())

        server_status = bunch.status

        if server_status == 'abo':
            cached_sms_server_status = data_store.get_sms_server_status_from_cache(owner, repo, sms_name)
            if cached_sms_server_status is not None:

                print('building bunch from cache message...')
                cached_bunch = Bunch.create_from_dict(cached_sms_server_status['status'])
                print('building bunch from cache message...Done')

                previous_server_status = cached_bunch.status

                # if True:
                if is_new_abort_task_found(owner, repo, previous_server_status, error_task_dict_list):
                    takler_object_system_dict = data_store.save_sms_server_status_to_nwpc_takler_object_system(
                        owner, repo, sms_name,
                        message_data, error_task_dict_list
                    )

                    takler_object_system_store_flag = True

                    aborted_tasks_blob_id = None
                    for a_blob in takler_object_system_dict['blobs']:
                        if a_blob['data']['type'] == 'aborted_tasks':
                            aborted_tasks_blob_id = a_blob['id']

                    warning_data = {
                        'owner': owner,
                        'repo': repo,
                        'sms_server_name': sms_name,  # bunch.name
                        'message_datetime': message_datetime,
                        'suite_error_map': suite_error_map,
                        'aborted_tasks_blob_id': aborted_tasks_blob_id
                    }

                    # ding_talk_app = ding_talk.DingTalkApp(
                    #     ding_talk_config=app.config['BROKER_CONFIG']['ding_talk_app'],
                    #     cloud_config=app.config['BROKER_CONFIG']['cloud']
                    # )
                    #
                    # ding_talk_app.send_warning_message(warning_data)

                    weixin_app = weixin.WeixinApp(
                        weixin_config=current_app.config['BROKER_CONFIG']['weixin_app'],
                        cloud_config=current_app.config['BROKER_CONFIG']['cloud']
                    )
                    weixin_app.send_warning_message(warning_data)

        # 保存 error_task_list 到缓存
        error_task_value = {
            'timestamp': datetime.datetime.utcnow(),
            'error_task_list': error_task_dict_list
        }
        data_store.save_error_task_list_to_cache(owner, repo, error_task_value)

        data_store.save_sms_server_status_to_cache(owner, repo, sms_name, message_data)

        # 发送给外网服务器
        website_url = current_app.config['BROKER_CONFIG']['cloud']['put']['url'].format(
            owner=owner,
            repo=repo
        )
        if takler_object_system_store_flag:
            post_message = {
                'app': 'nwpc_monitor_broker',
                'event': 'post_sms_status',
                'timestamp': datetime.datetime.utcnow(),
                'data': {
                    'type': 'takler_object',
                    'blobs': takler_object_system_dict['blobs'],
                    'trees': takler_object_system_dict['trees'],
                    'commits': takler_object_system_dict['commits']
                }
            }

            website_post_data = {
                'message': json.dumps(post_message)
            }
        else:
            message_data['type'] = 'status'
            post_message = {
                'app': 'nwpc_monitor_broker',
                'event': 'post_sms_status',
                'timestamp': datetime.datetime.utcnow(),
                'data': message_data
            }
            website_post_data = {
                'message': json.dumps(post_message)
            }

        print('gzip the data...')
        gzipped_post_data = gzip.compress(bytes(json.dumps(website_post_data), 'utf-8'))
        print('gzip the data...done')

        response = requests.post(
            website_url,
            data=gzipped_post_data,
            headers={
                'content-encoding': 'gzip'
            },
            timeout=REQUEST_POST_TIME_OUT
        )
        print(response)
        return


@api_v3_app.route('/workflow/repos/<owner>/<repo>/status', methods=['POST'])
def receive_sms_status_message(owner, repo):
    """
    接收外部发送来的 SMS 服务器的状态，将其保存到本地缓存，并发送到外网服务器
    :return:
    """
    start_time = datetime.datetime.utcnow()

    content_encoding = request.headers.get('content-encoding', '').lower()
    if content_encoding == 'gzip':
        gzipped_data = request.data
        data_string = gzip.decompress(gzipped_data)
        body = json.loads(data_string.decode('utf-8'))
    else:
        body = request.form

    message = json.loads(body['message'])

    if 'error' in message:
        result = {
            'status': 'ok'
        }
        return jsonify(result)

    message_data = message['data']
    sms_status_message_handler(message_data)

    result = {
        'status': 'ok'
    }
    end_time = datetime.datetime.utcnow()
    print(end_time - start_time)

    return jsonify(result)
